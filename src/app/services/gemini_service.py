"""
Service for integration with Google Gemini AI
"""

import os
import asyncio
import tempfile

from typing import Optional
import google.generativeai as genai

from .storage_service import storage_service
from src.app.config import settings


class GeminiService:
    """Service for integration with Google Gemini AI"""

    def __init__(self):
        self.api_key = settings.gemini_api_key
        if not self.api_key:
            print("‚ö†Ô∏è  GEMINI_API_KEY is not configured. Using simulated responses.")
            self.model = None
        else:
            try:
                # Configurar Gemini
                genai.configure(api_key=self.api_key)
                self.model = genai.GenerativeModel("gemini-1.5-flash")
                print(
                    f"‚úÖ Gemini configured correctly with API key: {self.api_key[:10]}..."
                )
            except Exception as e:
                print(f"‚ùå Error configuring Gemini: {e}")
                print(f"   API Key used: {self.api_key[:10]}...")
                self.model = None

    async def generate_response(
        self,
        question_text: str,
        context_text: Optional[str] = None,
        context_type: str = "text",
        context_file_path: Optional[str] = None,
        action: str = "create",
    ) -> str:
        """
        Generate response using Gemini AI

        Args:
            question_text: Text of the question
            context_text: Text context (optional)
            context_type: Type of context (text or pdf)
            context_file_path: Path of the PDF file in MinIO (optional)
            action: Action that is being performed (create, update, recalculate)

        Returns:
            str: Response generated by Gemini
        """
        try:
            if not self.model:
                return self._simulate_response(question_text, context_type, action)

            if context_type == "pdf" and context_file_path:
                response = await self._generate_with_pdf(
                    question_text, context_file_path, action
                )
            else:
                response = await self._generate_with_text(
                    question_text, context_text, action
                )

            return response

        except Exception as e:
            error_msg = str(e)
            if "429" in error_msg or "quota" in error_msg.lower():
                print(f"‚ö†Ô∏è  Gemini quota exceeded. Using simulated response.")
                print(f"   Detalles: {error_msg[:100]}...")
            else:
                print(f"‚ùå Error generating response with Gemini: {e}")
            return self._simulate_response(question_text, context_type, action)

    def _build_prompt(
        self,
        question_text: str,
        context_text: Optional[str],
        context_type: str,
        action: str,
    ) -> str:
        """Build optimized prompt for specific university context"""

        action_instructions = {
            "create": "Responde √öNICAMENTE bas√°ndote en el contexto universitario proporcionado.",
            "update": "Actualiza la respuesta bas√°ndote EXCLUSIVAMENTE en el contexto universitario proporcionado.",
            "recalculate": "Recalcula la respuesta usando SOLO la informaci√≥n del contexto universitario proporcionado.",
        }

        instruction = action_instructions.get(action, action_instructions["create"])

        prompt = f"INSTRUCCI√ìN IMPORTANTE: {instruction}\n\n"
        prompt += f"Pregunta: {question_text}\n\n"

        if context_text and context_text.strip():
            source_info = (
                "extra√≠do de documento PDF"
                if context_type == "pdf"
                else "proporcionado"
            )
            prompt += f"CONTEXTO UNIVERSITARIO ({source_info}):\n{context_text}\n\n"

            prompt += """INSTRUCCIONES ESTRICTAS:
1. Responde √öNICAMENTE con informaci√≥n contenida en el contexto universitario proporcionado
2. NO agregues informaci√≥n externa, conocimiento general o datos de otras fuentes
3. Si el contexto no contiene informaci√≥n suficiente para responder completamente, indica claramente qu√© informaci√≥n espec√≠fica falta
4. Mant√©n un tono acad√©mico y profesional apropiado para el contexto universitario
5. Referencia espec√≠ficamente las partes del contexto que usas en tu respuesta
6. Si la pregunta no puede responderse con el contexto dado, responde: "La informaci√≥n proporcionada en el contexto no es suficiente para responder esta pregunta. Se necesitar√≠a informaci√≥n adicional sobre [especifica qu√© informaci√≥n]."

Respuesta basada EXCLUSIVAMENTE en el contexto universitario:"""

        else:
            # Si no hay contexto, ser expl√≠cito
            prompt += """NOTA: No se ha proporcionado contexto universitario espec√≠fico para esta pregunta.

INSTRUCCIONES:
1. Indica claramente que no hay contexto universitario disponible
2. Explica que no puedes responder sin el contexto espec√≠fico de la instituci√≥n
3. Sugiere qu√© tipo de informaci√≥n universitaria ser√≠a necesaria
4. Mant√©n un tono acad√©mico y profesional

Respuesta:"""

        return prompt

    async def _generate_with_text(
        self, question_text: str, context_text: Optional[str], action: str
    ) -> str:
        """Generate response with text context"""
        prompt = self._build_prompt(question_text, context_text, "text", action)
        return await self._generate_with_gemini(prompt)

    async def _generate_with_pdf(
        self, question_text: str, context_file_path: str, action: str
    ) -> str:
        """Generate response with PDF file using genai.upload_file()"""
        try:
            print(f"üìÑ Downloading PDF from MinIO: {context_file_path}")
            file_stream = storage_service.get_file_stream(context_file_path)

            # Crear archivo temporal
            with tempfile.NamedTemporaryFile(delete=False, suffix=".pdf") as temp_file:
                # Escribir el contenido del stream al archivo temporal
                for chunk in file_stream:
                    temp_file.write(chunk)
                temp_file_path = temp_file.name

            try:
                print(f"üì§ Uploading PDF to Gemini...")
                uploaded_file = genai.upload_file(temp_file_path)
                print(f"‚úÖ PDF uploaded to Gemini: {uploaded_file.name}")

                action_instructions = {
                    "create": "Responde √öNICAMENTE bas√°ndote en el documento PDF universitario proporcionado.",
                    "update": "Actualiza la respuesta bas√°ndote EXCLUSIVAMENTE en el documento PDF universitario proporcionado.",
                    "recalculate": "Recalcula la respuesta usando SOLO la informaci√≥n del documento PDF universitario proporcionado.",
                }

                instruction = action_instructions.get(
                    action, action_instructions["create"]
                )

                prompt = f"""INSTRUCCI√ìN IMPORTANTE: {instruction}

Pregunta: {question_text}

INSTRUCCIONES ESTRICTAS:
1. Analiza el documento PDF universitario proporcionado
2. Responde √öNICAMENTE con informaci√≥n contenida en el documento
3. NO agregues informaci√≥n externa, conocimiento general o datos de otras fuentes
4. Si el documento no contiene informaci√≥n suficiente, indica qu√© informaci√≥n espec√≠fica falta
5. Mant√©n un tono acad√©mico y profesional apropiado para el contexto universitario
6. Referencia espec√≠ficamente las partes del documento que usas
7. Si la pregunta no puede responderse con el documento, responde: "La informaci√≥n en el documento no es suficiente para responder esta pregunta. Se necesitar√≠a informaci√≥n adicional sobre [especifica qu√© informaci√≥n]."

Respuesta basada EXCLUSIVAMENTE en el documento PDF universitario:"""

                response = await self._generate_with_gemini_and_file(
                    prompt, uploaded_file
                )

                return response

            finally:
                if os.path.exists(temp_file_path):
                    os.unlink(temp_file_path)

        except Exception as e:
            print(f"‚ùå Error processing PDF with Gemini: {e}")
            return self._simulate_response(question_text, "pdf", action)

    async def _generate_with_gemini_and_file(self, prompt: str, uploaded_file) -> str:
        """Generar respuesta usando Gemini con archivo subido"""
        try:
            loop = asyncio.get_event_loop()
            response = await loop.run_in_executor(
                None, lambda: self.model.generate_content([prompt, uploaded_file])
            )

            if response and response.text:
                return response.text.strip()
            else:
                raise Exception("Empty response from Gemini")

        except Exception as e:
            print(f"‚ùå Error generating with Gemini and file: {e}")
            raise

    async def _generate_with_gemini(self, prompt: str) -> str:
        """Generate response using Gemini asynchronously"""
        try:
            # Ejecutar en thread pool para no bloquear el event loop
            loop = asyncio.get_event_loop()
            response = await loop.run_in_executor(
                None, lambda: self.model.generate_content(prompt)
            )

            if response and response.text:
                return response.text.strip()
            else:
                raise Exception("Respuesta vac√≠a de Gemini")

        except Exception as e:
            print(f"‚ùå Error en la generaci√≥n con Gemini: {e}")
            raise

    def _simulate_response(
        self, question_text: str, context_type: str, action: str
    ) -> str:
        """Generate simulated response when Gemini is not available"""
        action_messages = {
            "create": "Procesamiento completado",
            "update": "Actualizaci√≥n procesada",
            "recalculate": "Rec√°lculo completado",
        }

        action_msg = action_messages.get(action, "Procesamiento completado")

        return (
            f"{action_msg} para '{question_text[:50]}{'...' if len(question_text) > 50 else ''}'. "
            f"El sistema ha analizado el contexto de tipo {context_type} y ha generado esta respuesta "
            f"detallada que incorpora conocimiento relevante del dominio. La acci√≥n de {action} se "
            f"ejecut√≥ correctamente, resultando en una respuesta que combina precisi√≥n t√©cnica con "
            f"claridad comunicativa para el usuario final."
        )


gemini_service = GeminiService()
